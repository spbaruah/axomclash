import React, { useState, useEffect, useRef, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  FaUser, FaPaperPlane, FaEllipsisV, 
  FaGraduationCap, FaUsers,
  FaImage, FaFile, FaTrash, FaReply,
  FaHeart, FaRegHeart, FaEllipsisH, FaTimes, FaPlus, FaEdit,
  FaSmile, FaThumbsUp, FaLaugh, FaSadTear, FaAngry, FaSurprise
} from 'react-icons/fa';
import { useAuth } from '../../contexts/AuthContext';
import { useSocket } from '../../contexts/SocketContext';
import axios from 'axios';

import './Chat.css';

const Chat = () => {
  const { userProfile, loading } = useAuth();
  const { socket, isConnected, sendMessage: socketSendMessage } = useSocket();
  const [selectedChat, setSelectedChat] = useState(null);
  const [message, setMessage] = useState('');

  const [messages, setMessages] = useState([]);
  const [chats, setChats] = useState([]);
  const [onlineUsers, setOnlineUsers] = useState(1);
  const [isTyping, setIsTyping] = useState(false);
  const [typingUsers, setTypingUsers] = useState([]);
  const [showMediaOptions, setShowMediaOptions] = useState(false);
  const [selectedFile, setSelectedFile] = useState(null);
  const [replyTo, setReplyTo] = useState(null);
  const [editingMessage, setEditingMessage] = useState(null);
  const [showReactionPicker, setShowReactionPicker] = useState(null);
  const [showMessageMenu, setShowMessageMenu] = useState(null);

  // Refs
  const fileInputRef = useRef(null);
  const messagesEndRef = useRef(null);
  const typingTimeoutRef = useRef(null);
  const messageMenuRef = useRef(null);
  const reactionPickerRef = useRef(null);

  // Close menus when clicking outside
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (messageMenuRef.current && !messageMenuRef.current.contains(event.target)) {
        setShowMessageMenu(null);
      }
      if (reactionPickerRef.current && !reactionPickerRef.current.contains(event.target)) {
        setShowReactionPicker(null);
      }
    };

    // Handle window resize to reposition reaction picker
    const handleResize = () => {
      if (showReactionPicker) {
        // Force re-render to recalculate positioning
        setShowReactionPicker(null);
        setTimeout(() => setShowReactionPicker(showReactionPicker), 10);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    window.addEventListener('resize', handleResize);
    
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
      window.removeEventListener('resize', handleResize);
    };
  }, [showReactionPicker]);

  // Initialize college chat room when component mounts
  useEffect(() => {
    // Don't proceed if still loading authentication
    if (loading) {
      console.log('Auth still loading, waiting...');
      return;
    }
    
    // Don't proceed if user is not authenticated
    if (!userProfile) {
      console.log('User not authenticated, waiting...');
      return;
    }
    
    if (userProfile && userProfile.college_id) {
      const collegeChat = {
        id: `college-${userProfile.college_id}`,
        name: `${userProfile.college_name || 'Your College'} Chat Room`,
        lastMessage: 'No messages yet',
        time: 'Just now',
        unread: 0,
        isGroup: true,
        isCollegeChat: true,
        collegeId: userProfile.college_id
      };
      
      setChats([collegeChat]);
      setSelectedChat(collegeChat);
      
      // Try to load cached messages first
      const cachedMessages = localStorage.getItem(`chat_messages_${userProfile.college_id}`);
      if (cachedMessages) {
        try {
          const parsedMessages = JSON.parse(cachedMessages);
                     // Ensure cached messages have correct ownership and message content
           const processedMessages = parsedMessages.map(msg => ({
             ...msg,
             isOwn: msg.sender === userProfile?.username || msg.isOwn,
             message: msg.content || msg.message || '' // Handle both content and message fields
           }));
           console.log('Cached Messages processed:', processedMessages.map(m => ({ 
             id: m.id, 
             sender: m.sender, 
             isOwn: m.isOwn, 
             message: m.message,
             content: m.content 
           })));
           setMessages(processedMessages);
        } catch (e) {
          console.error('Error parsing cached messages:', e);
          setMessages([]);
        }
      } else {
        setMessages([]);
      }

      // Load existing messages from API
      loadMessages();
    }
  }, [userProfile, loading]);

  // Add welcome message if no messages exist
  useEffect(() => {
    if (messages.length === 0 && userProfile?.college_id && !loading) {
      const welcomeMessage = {
        id: 'welcome-' + Date.now(),
        sender: 'System',
        message: `Welcome to ${userProfile.college_name || 'Your College'} chat room! Start chatting with your fellow students.`,
        time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
        isOwn: false,
        message_type: 'text',
        isSystemMessage: true
      };
      console.log('Adding welcome message:', welcomeMessage);
      setMessages([welcomeMessage]);
    }
  }, [messages.length, userProfile, loading]);

  // Save messages to localStorage
  const saveMessagesToCache = useCallback((messagesToSave) => {
    if (userProfile?.college_id) {
      try {
        localStorage.setItem(`chat_messages_${userProfile.college_id}`, JSON.stringify(messagesToSave));
      } catch (e) {
        console.error('Error saving messages to cache:', e);
      }
    }
  }, [userProfile?.college_id]);

  // Load messages from API
  const loadMessages = useCallback(async () => {
    if (!userProfile?.college_id) return;
    
    try {
      const token = localStorage.getItem('authToken');
      const response = await axios.get(`/api/chat/college/${userProfile.college_id}`, {
        headers: { Authorization: `Bearer ${token}` }
      });
      
             if (response.data.messages) {
         setMessages(prevMessages => {
                                    const apiMessages = response.data.messages.map(msg => ({
               ...msg,
               isOwn: msg.username === userProfile?.username,
               sender: msg.username || msg.sender,
               full_name: msg.full_name || msg.username, // Use full_name if available, fallback to username
               student_status: msg.student_status || 'Currently Studying', // Default to currently studying
               message: msg.content || msg.message || '', // Handle both content and message fields
               time: msg.created_at ? new Date(msg.created_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : msg.time,
               reactions: msg.reactions || {}, // Ensure reactions are loaded from backend
               userReactions: msg.userReactions || {} // Ensure user reactions are loaded from backend
             }));
            
            console.log('API Messages with reactions:', apiMessages.map(m => ({ 
              id: m.id, 
              sender: m.sender, 
              reactions: m.reactions,
              userReactions: m.userReactions
            })));
           
           console.log('API Messages processed:', apiMessages.map(m => ({ 
             id: m.id, 
             sender: m.sender, 
             isOwn: m.isOwn, 
             message: m.message,
             content: m.content 
           })));
           
                       const existingIds = new Set(prevMessages.map(msg => msg.id));
            
            // Add new API messages that don't exist in cache
            const newMessages = apiMessages.filter(apiMsg => !existingIds.has(apiMsg.id));
            const mergedMessages = [...prevMessages, ...newMessages];
            
            console.log('Merged messages with reactions:', mergedMessages.map(m => ({ 
              id: m.id, 
              sender: m.sender, 
              reactions: m.reactions,
              userReactions: m.userReactions
            })));
            
            // Save merged messages to cache
            saveMessagesToCache(mergedMessages);
            
            return mergedMessages;
         });
       }
    } catch (error) {
      console.error('Error loading messages:', error);
    }
  }, [userProfile?.college_id, saveMessagesToCache]);

  // Refresh reactions for a specific message
  const refreshMessageReactions = useCallback(async (messageId) => {
    if (!userProfile?.college_id) return;
    
    try {
      const token = localStorage.getItem('authToken');
      const response = await axios.get(`/api/chat/college/${userProfile.college_id}`, {
        headers: { Authorization: `Bearer ${token}` }
      });
      
      if (response.data.messages) {
        const messageWithReactions = response.data.messages.find(msg => msg.id === messageId);
        if (messageWithReactions) {
          setMessages(prev => prev.map(msg => 
            msg.id === messageId 
              ? { 
                  ...msg, 
                  reactions: messageWithReactions.reactions || {},
                  userReactions: messageWithReactions.userReactions || {}
                }
              : msg
          ));
        }
      }
    } catch (error) {
      console.error('Error refreshing message reactions:', error);
    }
  }, [userProfile?.college_id]);

  // Listen for new messages from socket
  useEffect(() => {
    if (socket) {
      socket.on('new-message', (data) => {
        if (data.collegeId === userProfile?.college_id) {
          if (data.username !== userProfile?.username) {
                         const newMessage = {
               id: data.id || Date.now(),
               sender: data.username,
               full_name: data.full_name || data.username,
               student_status: data.student_status || 'Currently Studying',
               message: data.message,
               time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
               isOwn: false,
               message_type: data.message_type || 'text',
               reply_to: data.reply_to || null,
               reactions: data.reactions || {}
             };
            
            setMessages(prev => {
              const messageExists = prev.some(msg => msg.id === newMessage.id);
              if (messageExists) return prev;
              
              const updatedMessages = [...prev, newMessage];
              saveMessagesToCache(updatedMessages);
              return updatedMessages;
            });
            
            setChats(prev => prev.map(chat => 
              chat.isCollegeChat 
                ? { ...chat, lastMessage: data.message, time: 'Just now' }
                : chat
            ));
          }
        }
      });

      socket.on('new-media-message', (data) => {
        if (data.collegeId === userProfile?.college_id) {
          if (data.username !== userProfile?.username) {
                         const newMessage = {
               id: Date.now(),
               sender: data.username,
               full_name: data.full_name || data.username,
               student_status: data.student_status || 'Currently Studying',
               message: data.caption || '',
               time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
               isOwn: false,
               message_type: data.message_type,
               media_url: data.media_url,
               reply_to: data.reply_to || null,
               reactions: data.reactions || {}
             };
            
            setMessages(prev => {
              const messageExists = prev.some(msg => msg.id === newMessage.id);
              if (messageExists) return prev;
              
              const updatedMessages = [...prev, newMessage];
              saveMessagesToCache(updatedMessages);
              return updatedMessages;
            });
          }
        }
      });



      socket.on('college-users-update', (data) => {
        if (data.collegeId === userProfile?.college_id) {
          setOnlineUsers(data.onlineUsers);
        }
      });

      // Listen for user connection events
      socket.on('user-connected', (data) => {
        if (data.collegeId === userProfile?.college_id) {
          console.log('User connected:', data.username);
        }
      });

      socket.on('user-disconnected', (data) => {
        if (data.collegeId === userProfile?.college_id) {
          console.log('User disconnected:', data.username);
        }
      });

      socket.on('user-typing', (data) => {
        if (data.collegeId === userProfile?.college_id && data.userId !== userProfile?.id) {
          setTypingUsers(prev => {
            const existing = prev.find(u => u.userId === data.userId);
            if (!existing) {
              return [...prev, { userId: data.userId, username: data.username }];
            }
            return prev;
          });
        }
      });

      socket.on('user-stop-typing', (data) => {
        if (data.collegeId === userProfile?.college_id) {
          setTypingUsers(prev => prev.filter(u => u.userId !== data.userId));
        }
      });

      socket.on('message-edited', (data) => {
        if (data.collegeId === userProfile?.college_id) {
          setMessages(prev => prev.map(msg => 
            msg.id === data.messageId 
              ? { ...msg, message: data.newContent, edited: true }
              : msg
          ));
        }
      });

      socket.on('message-deleted', (data) => {
        if (data.collegeId === userProfile?.college_id) {
          setMessages(prev => prev.filter(msg => msg.id !== data.messageId));
        }
      });

      socket.on('message-reacted', (data) => {
        if (data.collegeId === userProfile?.college_id) {
          // Update the message reactions immediately for smooth UX
          setMessages(prev => prev.map(msg => {
            if (msg.id === data.messageId) {
              const newReactions = { ...msg.reactions };
              const newUserReactions = { ...msg.userReactions };
              
              if (data.action === 'add') {
                // Add new reaction
                if (!newReactions[data.reaction]) {
                  newReactions[data.reaction] = 0;
                }
                newReactions[data.reaction] += 1;
                
                // Mark this as user's reaction
                newUserReactions[data.reaction] = true;
                
                // Remove any other reactions from this user (since only 1 reaction per user)
                Object.keys(newUserReactions).forEach(reactionType => {
                  if (reactionType !== data.reaction && newUserReactions[reactionType]) {
                    newUserReactions[reactionType] = false;
                    if (newReactions[reactionType] > 0) {
                      newReactions[reactionType] -= 1;
                      if (newReactions[reactionType] === 0) {
                        delete newReactions[reactionType];
                      }
                    }
                  }
                });
              } else if (data.action === 'remove') {
                // Remove reaction
                if (newReactions[data.reaction] && newReactions[data.reaction] > 0) {
                  newReactions[data.reaction] -= 1;
                  if (newReactions[data.reaction] === 0) {
                    delete newReactions[data.reaction];
                  }
                }
                newUserReactions[data.reaction] = false;
              }
              
              return {
                ...msg,
                reactions: newReactions,
                userReactions: newUserReactions
              };
            }
            return msg;
          }));
          
          // Also refresh from backend to ensure accuracy
          setTimeout(() => refreshMessageReactions(data.messageId), 100);
        }
      });

      return () => {
        socket.off('new-message');
        socket.off('new-media-message');
        socket.off('college-users-update');
        socket.off('user-connected');
        socket.off('user-disconnected');
        socket.off('user-typing');
        socket.off('user-stop-typing');
        socket.off('message-edited');
        socket.off('message-deleted');
        socket.off('message-reacted');
      };
    }
  }, [socket, userProfile, loading, saveMessagesToCache]);

  // Auto-scroll to bottom when new messages arrive
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  // Handle typing indicator
  const handleTyping = useCallback(() => {
    if (!isTyping && socket && selectedChat?.isCollegeChat) {
      setIsTyping(true);
      socket.emit('typing-start', {
        userId: userProfile?.id,
        username: userProfile?.username,
        collegeId: userProfile?.college_id
      });
    }

    // Clear existing timeout
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }

    // Set new timeout to stop typing indicator
    typingTimeoutRef.current = setTimeout(() => {
      if (isTyping && socket && selectedChat?.isCollegeChat) {
        setIsTyping(false);
        socket.emit('typing-stop', {
          userId: userProfile?.id,
          collegeId: userProfile?.college_id
        });
      }
    }, 1000);
  }, [isTyping, socket, selectedChat, userProfile, loading]);

  const handleSendMessage = useCallback(async () => {
    if ((message.trim() || editingMessage) && selectedChat && isConnected) {
      try {
        const token = localStorage.getItem('authToken');
        
        if (editingMessage) {
          // Edit existing message
          const response = await axios.put(
            `/api/chat/message/${editingMessage.id}`,
            { content: message.trim() },
            { headers: { Authorization: `Bearer ${token}` } }
          );

          // Update message in local state
          setMessages(prev => prev.map(msg => 
            msg.id === editingMessage.id 
              ? { ...msg, message: message.trim(), edited: true }
              : msg
          ));

          // Send edit through socket
          if (selectedChat.isCollegeChat) {
            socket.emit('edit-message', {
              messageId: editingMessage.id,
              newContent: message.trim(),
              collegeId: userProfile.college_id
            });
          }

          setEditingMessage(null);
        } else {
          // Send new message
          const response = await axios.post(
            `/api/chat/college/${userProfile.college_id}/text`,
            { content: message.trim() },
            { headers: { Authorization: `Bearer ${token}` } }
          );

          // Use the actual message ID from the backend response
          const messageId = response.data.chatMessage.id;
                     const newMessage = {
             id: messageId,
             sender: userProfile?.username || 'You',
             full_name: userProfile?.full_name || userProfile?.username || 'You',
             student_status: userProfile?.student_status || 'Currently Studying',
             message: message.trim(),
             time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
             isOwn: true,
             message_type: 'text',
             reply_to: replyTo ? {
               id: replyTo.id,
               message: replyTo.message,
               sender: replyTo.sender
             } : null,
             reactions: {}
           };

          // Add message to local state
          setMessages(prev => {
            const messageExists = prev.some(msg => msg.id === messageId);
            if (messageExists) return prev;
            
            const updatedMessages = [...prev, newMessage];
            saveMessagesToCache(updatedMessages);
            return updatedMessages;
          });

          // Send message through socket
          if (selectedChat.isCollegeChat) {
                         const socketMessage = {
               id: messageId,
               message: message.trim(),
               collegeId: userProfile.college_id,
               username: userProfile?.username || 'Anonymous',
               full_name: userProfile?.full_name || userProfile?.username || 'Anonymous',
               student_status: userProfile?.student_status || 'Currently Studying',
               userId: userProfile?.id,
               timestamp: new Date().toISOString(),
               message_type: 'text',
               reply_to: replyTo ? {
                 id: replyTo.id,
                 message: replyTo.message,
                 sender: replyTo.sender
               } : null,
               reactions: {}
             };
            
            socketSendMessage(socketMessage);
          }
        }

        setMessage('');
        setReplyTo(null);
        
        // Stop typing indicator
        if (isTyping && socket) {
          setIsTyping(false);
          socket.emit('typing-stop', {
            userId: userProfile?.id,
            collegeId: userProfile?.college_id
          });
        }
      } catch (error) {
        console.error('Error sending message:', error);
        if (error.response?.status === 401) {
          alert('Authentication error. Please log in again.');
        } else if (error.response?.status === 403) {
          alert('You are not authorized to send messages to this college.');
        } else {
          alert('Failed to send message. Please try again.');
        }
      }
    }
  }, [message, selectedChat, isConnected, userProfile, replyTo, isTyping, socket, socketSendMessage, editingMessage]);

  // Handle message deletion
  const handleDeleteMessage = useCallback(async (messageId) => {
    try {
      const token = localStorage.getItem('authToken');
      await axios.delete(`/api/chat/message/${messageId}`, {
        headers: { Authorization: `Bearer ${token}` }
      });

      // Remove message from local state
      setMessages(prev => prev.filter(msg => msg.id !== messageId));

      // Send delete through socket
      if (selectedChat?.isCollegeChat) {
        socket.emit('delete-message', {
          messageId: messageId,
          collegeId: userProfile.college_id
        });
      }

      setShowMessageMenu(null);
    } catch (error) {
      console.error('Error deleting message:', error);
      alert('Failed to delete message. Please try again.');
    }
  }, [selectedChat, userProfile, socket]);

  // Handle message reaction
  const handleReaction = useCallback(async (messageId, reaction) => {
    try {
      const token = localStorage.getItem('authToken');
      const message = messages.find(msg => msg.id === messageId);
      
      // Check if user already has this exact reaction
      const hasThisReaction = message.userReactions && message.userReactions[reaction];
      
      // Update local state immediately for smooth UX
      setMessages(prev => prev.map(msg => {
        if (msg.id === messageId) {
          const newReactions = { ...msg.reactions };
          const newUserReactions = { ...msg.userReactions };
          
          if (hasThisReaction) {
            // Remove reaction
            if (newReactions[reaction] && newReactions[reaction] > 0) {
              newReactions[reaction] -= 1;
              if (newReactions[reaction] === 0) {
                delete newReactions[reaction];
              }
            }
            newUserReactions[reaction] = false;
          } else {
            // Add new reaction
            if (!newReactions[reaction]) {
              newReactions[reaction] = 0;
            }
            newReactions[reaction] += 1;
            
            // Mark this as user's reaction
            newUserReactions[reaction] = true;
            
            // Remove any other reactions from this user (since only 1 reaction per user)
            Object.keys(newUserReactions).forEach(reactionType => {
              if (reactionType !== reaction && newUserReactions[reactionType]) {
                newUserReactions[reactionType] = false;
                if (newReactions[reactionType] > 0) {
                  newReactions[reactionType] -= 1;
                  if (newReactions[reactionType] === 0) {
                    delete newReactions[reactionType];
                  }
                }
              }
            });
          }
          
          return {
            ...msg,
            reactions: newReactions,
            userReactions: newUserReactions
          };
        }
        return msg;
      }));
      
      if (hasThisReaction) {
        // User already has this reaction, remove it
        await axios.delete(`/api/chat/message/${messageId}/reaction`, {
          data: { reaction },
          headers: { Authorization: `Bearer ${token}` }
        });

        socket.emit('message-reaction', {
          messageId,
          reaction,
          action: 'remove',
          userId: userProfile.id,
          collegeId: userProfile.college_id
        });
      } else {
        // Add or update reaction (backend will handle replacing existing reaction)
        await axios.post(`/api/chat/message/${messageId}/reaction`, 
          { reaction },
          { headers: { Authorization: `Bearer ${token}` } }
        );

        socket.emit('message-reaction', {
          messageId,
          reaction,
          action: 'add',
          userId: userProfile.id,
          collegeId: userProfile.college_id
        });
      }

      setShowReactionPicker(null);
    } catch (error) {
      console.error('Error reacting to message:', error);
      // Revert local state on error
      refreshMessageReactions(messageId);
    }
  }, [messages, userProfile, socket, refreshMessageReactions]);



  // File handling
  const handleFileSelect = useCallback((event) => {
    const file = event.target.files[0];
    if (file) {
      setSelectedFile(file);
      setShowMediaOptions(false);
    }
  }, []);

  const sendMediaMessage = useCallback(async () => {
    if (!selectedFile) return;

    try {
      const token = localStorage.getItem('authToken');
      const formData = new FormData();
      formData.append('media', selectedFile);
      formData.append('messageType', selectedFile.type.startsWith('image/') ? 'photo' : 'document');
      formData.append('caption', message.trim() || '');

      const response = await axios.post(
        `/api/chat/college/${userProfile.college_id}/media`,
        formData,
        { 
          headers: { 
            Authorization: `Bearer ${token}`,
            'Content-Type': 'multipart/form-data'
          } 
        }
      );

             const newMessage = {
         id: Date.now(),
         sender: userProfile?.username || 'You',
         full_name: userProfile?.full_name || userProfile?.username || 'You',
         student_status: userProfile?.student_status || 'Currently Studying',
         message: message.trim() || '',
         time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
         isOwn: true,
         message_type: selectedFile.type.startsWith('image/') ? 'photo' : 'document',
         media_url: response.data.chatMessage.media_url,
         reply_to: replyTo ? {
           id: replyTo.id,
           message: replyTo.message,
           sender: replyTo.sender
         } : null,
         reactions: {}
       };

      setMessages(prev => {
        const updatedMessages = [...prev, newMessage];
        saveMessagesToCache(updatedMessages);
        return updatedMessages;
      });

      // Send through socket
      if (socket && selectedChat?.isCollegeChat) {
                 const socketMessage = {
           collegeId: userProfile.college_id,
           username: userProfile?.username || 'Anonymous',
           full_name: userProfile?.full_name || userProfile?.username || 'Anonymous',
           student_status: userProfile?.student_status || 'Currently Studying',
           userId: userProfile?.id,
           message_type: newMessage.message_type,
           media_url: newMessage.media_url,
           caption: newMessage.message,
           timestamp: new Date().toISOString(),
           reply_to: replyTo ? {
             id: replyTo.id,
             message: replyTo.message,
             sender: replyTo.sender
           } : null,
           reactions: {}
         };
        
        socket.emit('send-media-message', socketMessage);
      }

      setSelectedFile(null);
      setMessage('');
    } catch (error) {
      console.error('Error sending media message:', error);
    }
  }, [selectedFile, message, userProfile, socket, selectedChat, replyTo]);

  const handleKeyPress = useCallback((e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    } else {
      handleTyping();
    }
  }, [handleSendMessage, handleTyping]);

    // Message rendering based on type
  const renderMessage = useCallback((msg) => {
    // Determine if this is the current user's message
    const isOwnMessage = msg.sender === userProfile?.username || msg.isOwn;
    const isSystemMessage = msg.isSystemMessage || msg.sender === 'System';
    const baseClasses = `message ${isSystemMessage ? 'system' : (isOwnMessage ? 'own' : 'other')}`;
    
    // Debug: Log message structure
    console.log('Rendering message:', {
      id: msg.id,
      sender: msg.sender,
      message: msg.message,
      message_type: msg.message_type,
      isOwn: msg.isOwn,
      isOwnMessage,
      isSystemMessage,
      baseClasses
    });
    
    const renderReplyPreview = () => {
      if (msg.reply_to) {
        return (
          <div className="reply-preview">
            <small>
              <strong>↩️ {msg.reply_to.sender}:</strong> {msg.reply_to.message}
            </small>
          </div>
        );
      }
      return null;
    };

    const renderReactions = () => {
      console.log('Rendering reactions for message:', msg.id, 'reactions:', msg.reactions, 'userReactions:', msg.userReactions);
      if (msg.reactions && Object.keys(msg.reactions).length > 0) {
        return (
          <div className="message-reactions">
            {Object.entries(msg.reactions).map(([reaction, count]) => {
              // Check if current user has this reaction
              const hasUserReaction = msg.userReactions && msg.userReactions[reaction];
              
              return (
                <div 
                  key={reaction} 
                  className={`reaction ${hasUserReaction ? 'own-reaction' : ''}`}
                  title={`${count} ${count === 1 ? 'person' : 'people'} reacted with ${reaction}${hasUserReaction ? ' (you)' : ''}`}
                >
                  <span className="reaction-emoji">{getReactionEmoji(reaction)}</span>
                  <span className="reaction-count">{count}</span>
                </div>
              );
            })}
          </div>
        );
      }
      return null;
    };

    const getReactionEmoji = (reaction) => {
      const reactionMap = {
        'like': '👍',
        'love': '❤️',
        'laugh': '😂',
        'wow': '😮',
        'sad': '😢',
        'angry': '😠'
      };
      return reactionMap[reaction] || reaction;
    };

        const renderMessageActions = () => {
      // Don't show actions for system messages
      if (isSystemMessage) {
        return null;
      }
      
      return (
        <div className="message-actions">
          {!isOwnMessage && (
            <button 
              className="reply-btn"
              onClick={() => setReplyTo(msg)}
              title="Reply to this message"
            >
              <FaReply />
            </button>
          )}
          <button 
            className="react-btn"
            onClick={(e) => {
              e.stopPropagation();
              setShowReactionPicker(showReactionPicker === msg.id ? null : msg.id);
            }}
            title="React to this message"
          >
            <FaSmile />
          </button>
          {isOwnMessage && (
            <button 
              className="menu-btn"
              onClick={(e) => {
                e.stopPropagation();
                setShowMessageMenu(showMessageMenu === msg.id ? null : msg.id);
              }}
              title="Message options"
            >
              <FaEllipsisH />
            </button>
          )}
        </div>
      );
    };

         const renderMessageHeader = () => {
       // Get the display name (full_name if available, otherwise username)
       const displayName = msg.full_name || msg.sender;
       const isAlumni = msg.student_status === 'Alumni';
       
       return (
         <div className="message-header">
           <div className="sender-info">
             <span className="message-sender">
               {displayName}
               {isAlumni && <span className="alumni-badge">👨‍🎓 Alumni</span>}
             </span>
           </div>
           <span className="message-time">
             {msg.time}
             {msg.edited && <span className="edited-indicator"> (edited)</span>}
           </span>
         </div>
       );
     };

    const renderMessageMenu = () => {
      if (showMessageMenu === msg.id && isOwnMessage && !isSystemMessage) {
        return (
          <div className="message-menu" ref={messageMenuRef}>
            <button 
              className="menu-item"
              onClick={() => {
                setEditingMessage(msg);
                setMessage(msg.message);
                setShowMessageMenu(null);
              }}
            >
              <FaEdit /> Edit
            </button>
            <button 
              className="menu-item delete"
              onClick={() => handleDeleteMessage(msg.id)}
            >
              <FaTrash /> Delete
            </button>
          </div>
        );
      }
      return null;
    };

    const renderReactionPicker = () => {
      if (showReactionPicker === msg.id && !isSystemMessage) {
        const reactions = [
          { emoji: '👍', code: 'like' },
          { emoji: '❤️', code: 'love' },
          { emoji: '😂', code: 'laugh' },
          { emoji: '😮', code: 'wow' },
          { emoji: '😢', code: 'sad' },
          { emoji: '😠', code: 'angry' }
        ];

        // Determine positioning and ensure picker stays completely within viewport
        const getPickerPosition = () => {
          if (typeof window !== 'undefined') {
            const messageElement = document.querySelector(`[data-message-id="${msg.id}"]`);
            if (messageElement) {
              const rect = messageElement.getBoundingClientRect();
              const pickerHeight = 60;
              const pickerWidth = 300; // Approximate width of reaction picker
              const viewportHeight = window.innerHeight;
              const viewportWidth = window.innerWidth;
              
              // Check vertical positioning
              const spaceAbove = rect.top;
              const spaceBelow = viewportHeight - rect.bottom;
              const shouldShowBelow = spaceBelow > spaceAbove || spaceAbove < pickerHeight + 20;
              
              // Calculate horizontal positioning based on message alignment
              let pickerLeft;
              let useRightPositioning = false;
              
              if (isOwnMessage) {
                // For right-aligned messages (own messages), position picker to the right of the message
                pickerLeft = rect.right - pickerWidth;
                
                // If the calculated position would go outside the right edge, use right positioning
                if (pickerLeft + pickerWidth > viewportWidth - 20) {
                  useRightPositioning = true;
                  pickerLeft = viewportWidth - pickerWidth - 20;
                }
              } else {
                // For left-aligned messages (other messages), center picker on message
                pickerLeft = rect.left + (rect.width / 2) - (pickerWidth / 2);
              }
              
              // Ensure picker doesn't go outside left edge
              if (pickerLeft < 20) {
                pickerLeft = 20;
              }
              
              // Ensure picker doesn't go outside right edge
              if (pickerLeft + pickerWidth > viewportWidth - 20) {
                pickerLeft = viewportWidth - pickerWidth - 20;
              }
              
              // Determine which CSS class to apply based on positioning
              let horizontalClass = '';
              if (pickerLeft <= 20) {
                horizontalClass = ' left-edge';
              } else if (pickerLeft + pickerWidth >= viewportWidth - 20) {
                horizontalClass = ' right-edge';
              }
              
              const verticalClass = shouldShowBelow ? ' below' : '';
              return {
                className: `reaction-picker${verticalClass}${horizontalClass}`,
                left: pickerLeft,
                useRightPositioning
              };
            }
          }
          return { className: 'reaction-picker', left: 20 };
        };

        const pickerPosition = getPickerPosition();
        const pickerClass = pickerPosition.className;
        const pickerLeft = pickerPosition.left;
        const useRightPositioning = pickerPosition.useRightPositioning;

        return (
          <div 
            className={pickerClass} 
            ref={reactionPickerRef}
            style={useRightPositioning ? { right: '20px' } : { left: `${pickerLeft}px` }}
          >
            {reactions.map((reaction) => {
              // Check if user has this reaction
              const hasUserReaction = msg.userReactions && msg.userReactions[reaction.code];
              const buttonClass = `reaction-option ${hasUserReaction ? 'active' : ''}`;
              
              return (
                <button
                  key={reaction.code}
                  className={buttonClass}
                  onClick={() => handleReaction(msg.id, reaction.code)}
                  title={hasUserReaction ? `Remove ${reaction.emoji} reaction` : `React with ${reaction.emoji}`}
                >
                  {reaction.emoji}
                </button>
              );
            })}
          </div>
        );
      }
      return null;
    };
    
         switch (msg.message_type) {
       case 'photo':
         return (
           <div className={baseClasses} data-message-id={msg.id}>
             {renderMessageHeader()}
             <div className="message-content">
               {renderReplyPreview()}
               <img src={msg.media_url} alt="Shared photo" className="message-photo" />
               {msg.message && <p>{msg.message}</p>}
               {renderReactions()}
             </div>
             {renderMessageActions()}
             {renderMessageMenu()}
             {renderReactionPicker()}
           </div>
         );
      

      
             case 'document':
         return (
           <div className={baseClasses} data-message-id={msg.id}>
             {renderMessageHeader()}
             <div className="message-content">
               {renderReplyPreview()}
               <div className="document-message">
                 <FaFile className="file-icon" />
                 <span className="file-name">{msg.media_url.split('/').pop()}</span>
                 <button className="download-btn">Download</button>
               </div>
               {msg.message && <p>{msg.message}</p>}
               {renderReactions()}
             </div>
             {renderMessageActions()}
             {renderMessageMenu()}
             {renderReactionPicker()}
           </div>
         );
      
                           default:
         return (
           <div className={baseClasses} data-message-id={msg.id}>
             {renderMessageHeader()}
             <div className="message-content">
               {renderReplyPreview()}
               {msg.message && msg.message.trim() !== '' ? (
                 <p>{msg.message}</p>
               ) : (
                 <p style={{ fontStyle: 'italic', opacity: 0.7 }}>No message content</p>
               )}
               {renderReactions()}
             </div>
             {renderMessageActions()}
             {renderMessageMenu()}
             {renderReactionPicker()}
           </div>
         );
    }
  }, [showMessageMenu, showReactionPicker, handleDeleteMessage, handleReaction]);

  useEffect(() => {
    if (chats.length > 0 && !selectedChat) {
      setSelectedChat(chats[0]);
    }
  }, [chats, selectedChat]);

  // Show loading state while authentication is in progress
  if (loading) {
    return (
      <div className="chat-container">
        <div className="chat-header">
          <h2>Chat</h2>
        </div>
        <div className="chat-content">
          <div className="no-chat-selected">
            <p>Loading chat...</p>
          </div>
        </div>
      </div>
    );
  }

  // Show login prompt if not authenticated
  if (!userProfile) {
    return (
      <div className="chat-container">
        <div className="chat-header">
          <h2>Chat</h2>
        </div>
        <div className="chat-content">
          <div className="no-chat-selected">
            <p>Please log in to access chat features.</p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="chat-container">
      <div className="chat-layout">
        {/* Chat Messages */}
        <motion.div
          initial={{ opacity: 0, x: 20 }}
          animate={{ opacity: 1, x: 0 }}
          className="chat-messages"
        >
          {selectedChat ? (
            <>
              {!isConnected && (
                <div className="connection-warning">
                  <span>⚠️ Connecting to chat server...</span>
                </div>
              )}
              
              <div className={`chat-messages-header ${selectedChat.isCollegeChat ? 'college-chat-header' : ''}`}>
                <div className="chat-user-info">
                  {selectedChat.isCollegeChat ? (
                    <FaGraduationCap className="user-avatar" />
                  ) : (
                    <FaUser className="user-avatar" />
                  )}
                  <div>
                    <h3>{selectedChat.name}</h3>
                    <span className="user-status">
                      {selectedChat.isCollegeChat 
                        ? `${onlineUsers} student${onlineUsers !== 1 ? 's' : ''} online` 
                        : (selectedChat.isGroup ? 'Group Chat' : 'Online')
                      }
                    </span>
                  </div>
                </div>
                <div className="chat-header-actions">
                  <button className="chat-options">
                    <FaEllipsisV />
                  </button>
                </div>
              </div>

                             <div className="messages-container">
                 {messages.length > 0 ? (
                   messages.map((msg, index) => (
                     <motion.div
                       key={msg.id || `msg-${index}`}
                       initial={{ opacity: 0, y: 10 }}
                       animate={{ opacity: 1, y: 0 }}
                       transition={{ delay: index * 0.1 }}
                       className="message-wrapper"
                     >
                       {renderMessage(msg)}
                     </motion.div>
                   ))
                 ) : (
                   <div className="no-messages">
                     <p>No messages yet. Start the conversation!</p>
                   </div>
                 )}
                 
                 {/* Typing indicators */}
                 <AnimatePresence>
                   {typingUsers.map(user => (
                     <motion.div
                       key={user.userId}
                       initial={{ opacity: 0, y: 10 }}
                       animate={{ opacity: 1, y: 0 }}
                       exit={{ opacity: 0, y: -10 }}
                       className="typing-indicator"
                     >
                       <div className="typing-dots">
                         <span></span>
                         <span></span>
                         <span></span>
                       </div>
                       <span className="typing-text">{user.username} is typing...</span>
                     </motion.div>
                   ))}
                 </AnimatePresence>
                 
                 <div ref={messagesEndRef} />
               </div>

              {/* Reply preview */}
              {replyTo && (
                <div className="reply-preview-bar">
                  <div className="reply-content">
                    <small>
                      <strong>↩️ Replying to {replyTo.sender}:</strong> {replyTo.message}
                    </small>
                  </div>
                  <button onClick={() => setReplyTo(null)} className="cancel-reply">
                    <FaTimes />
                  </button>
                </div>
              )}

              {/* Edit preview */}
              {editingMessage && (
                <div className="edit-preview-bar">
                  <div className="edit-content">
                    <small>
                      <strong>✏️ Editing message:</strong> {editingMessage.message}
                    </small>
                  </div>
                  <button onClick={() => setEditingMessage(null)} className="cancel-edit">
                    <FaTimes />
                  </button>
                </div>
              )}

              <div className="message-input">
                <div className="input-actions">
                  <button 
                    className="action-btn"
                    onClick={() => setShowMediaOptions(!showMediaOptions)}
                  >
                    <FaPlus />
                  </button>
                  
                  {showMediaOptions && (
                    <div className="media-options">
                      <button onClick={() => fileInputRef.current?.click()}>
                        <FaImage /> Photo
                      </button>
                      <button onClick={() => fileInputRef.current?.click()}>
                        <FaFile /> Document
                      </button>
                    </div>
                  )}
                  
                  <input
                    ref={fileInputRef}
                    type="file"
                    accept="image/*,.pdf,.doc,.docx"
                    onChange={handleFileSelect}
                    style={{ display: 'none' }}
                  />
                </div>

                <div className="input-field">
                  <input
                    type="text"
                    placeholder={editingMessage ? "Edit your message..." : "Type a message..."}
                    value={message}
                    onChange={(e) => setMessage(e.target.value)}
                    onKeyPress={handleKeyPress}
                    onKeyDown={handleTyping}
                  />
                </div>

                <div className="send-actions">
                  {selectedFile && (
                    <button className="send-media-btn" onClick={sendMediaMessage}>
                      Send {selectedFile.type.startsWith('image/') ? 'Photo' : 'Document'}
                    </button>
                  )}
                  
                  <button 
                    className="send-btn"
                    onClick={handleSendMessage}
                    disabled={!message.trim() && !selectedFile && !editingMessage}
                  >
                    <FaPaperPlane />
                  </button>
                </div>
              </div>
            </>
          ) : (
            <div className="no-chat-selected">
              <FaUser className="no-chat-icon" />
              <h3>Select a chat to start messaging</h3>
              <p>Choose from your conversations or start a new one</p>
            </div>
          )}
        </motion.div>
      </div>
    </div>
  );
};

export default Chat;




/* Facebook Messenger Style Chat CSS - Fixed Layout for Full Height */
.chat-container {
  height: 100vh; /* ✅ Use full viewport height instead of flex: 1 */
  overflow: hidden;
  background: #f8f9fa;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
  display: flex;
  flex-direction: column;
  position: relative; /* ✅ Add positioning context */
}

/* Adjust for bottom navigation if present */
.chat-container.with-bottom-nav {
  height: calc(100vh - 80px); /* ✅ Subtract bottom nav height */
}

.chat-layout {
  display: flex;
  flex: 1;
  height: 100%;
  overflow: hidden;
}

/* Connection Warning */
.connection-warning {
  background: #ffeaa7;
  color: #2d3436;
  padding: 8px 16px;
  text-align: center;
  font-size: 14px;
  border-bottom: 1px solid #fdcb6e;
  flex-shrink: 0; /* ✅ Prevent shrinking */
}

/* Chat Messages Section - Fixed to fill available height */
.chat-messages {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: #ffffff;
  border-radius: 8px;
  margin: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  overflow: hidden;
  min-height: 0; /* ✅ Allow shrinking */
}

/* Chat Header */
.chat-messages-header {
  background: #ffffff;
  padding: 12px 16px;
  border-bottom: 1px solid #e4e6ea;
  display: flex;
  align-items: center;
  justify-content: space-between;
  min-height: 60px;
  flex-shrink: 0; /* ✅ Prevent header from shrinking */
  z-index: 10;
}

.college-chat-header {
  background: linear-gradient(135deg, #7B42F6 0%, #C86DD7 100%);
  color: white;
  border-bottom: none;
}

.college-chat-header .user-status {
  color: rgba(255, 255, 255, 0.8) !important;
}

.chat-user-info {
  display: flex;
  align-items: center;
  gap: 12px;
}

.user-avatar {
  width: 40px;
  height: 40px;
  background: linear-gradient(135deg, #7B42F6 0%, #C86DD7 100%);
  color: white;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
}

.chat-user-info h3 {
  margin: 0;
  font-size: 16px;
  font-weight: 600;
  color: #1c1e21;
}

.college-chat-header .chat-user-info h3 {
  color: white;
}

.user-status {
  font-size: 12px;
  color: #65676b;
  margin-top: 2px;
}

.chat-header-actions {
  display: flex;
  gap: 8px;
}

.chat-options {
  background: none;
  border: none;
  color: #65676b;
  font-size: 16px;
  padding: 8px;
  border-radius: 50%;
  cursor: pointer;
  transition: background-color 0.2s;
}

.chat-options:hover {
  background: rgba(0, 0, 0, 0.05);
}

.college-chat-header .chat-options {
  color: rgba(255, 255, 255, 0.8);
}

.college-chat-header .chat-options:hover {
  background: rgba(255, 255, 255, 0.1);
}

/* Messages Container - Fixed to fill space and align messages to bottom */
.messages-container {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  display: flex;
  flex-direction: column;
  min-height: 0; /* ✅ Allow container to shrink if needed */
  scroll-behavior: smooth;
}

/* ✅ Better message positioning - messages flow naturally */
.messages-container > .message-wrapper:first-child {
  margin-top: auto;
}

.messages-container::-webkit-scrollbar {
  width: 6px;
}

.messages-container::-webkit-scrollbar-track {
  background: transparent;
}

.messages-container::-webkit-scrollbar-thumb {
  background: #bcc0c4;
  border-radius: 3px;
}

.messages-container::-webkit-scrollbar-thumb:hover {
  background: #8a8d91;
}

/* Message Wrapper */
.message-wrapper {
  margin-bottom: 4px;
  display: flex; /* ✅ Use flex for proper alignment */
  flex-direction: column;
}

/* Message Styles */
.message {
  max-width: 70%;
  margin-bottom: 8px;
  position: relative;
  animation: fadeIn 0.3s ease-out;
}

.message.own {
  align-self: flex-end;
}

.message.other {
  align-self: flex-start;
}

.message.system {
  align-self: center;
  max-width: 80%;
  text-align: center;
}

/* Message Header */
.message-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
  margin-bottom: 4px;
  font-size: 12px;
}

.sender-info {
  display: flex;
  align-items: center;
  gap: 6px;
}

.message-sender {
  font-weight: 600;
  color: #65676b;
  font-size: 12px;
}

.alumni-badge {
  background: linear-gradient(135deg, #7B42F6 0%, #C86DD7 100%);
  color: white;
  padding: 2px 6px;
  border-radius: 10px;
  font-size: 10px;
  font-weight: 500;
  margin-left: 4px;
}

.message-time {
  color: #65676b;
  font-size: 11px;
}

.edited-indicator {
  font-style: italic;
  opacity: 0.7;
}

/* Message Content */
.message-content {
  background: #f0f2f5;
  border-radius: 18px;
  padding: 8px 12px;
  position: relative;
  word-wrap: break-word;
  line-height: 1.4;
}

.message.own .message-content {
  background: linear-gradient(135deg, #7B42F6 0%, #C86DD7 100%);
  color: white;
}

.message.system .message-content {
  background: #e4e6ea;
  color: #65676b;
  font-style: italic;
  text-align: center;
  border-radius: 12px;
  padding: 6px 12px;
}

.message-content p {
  margin: 0;
  font-size: 14px;
}

/* Reply Preview */
.reply-preview {
  background: rgba(0, 0, 0, 0.1);
  border-radius: 8px;
  padding: 6px 8px;
  margin-bottom: 6px;
  font-size: 12px;
  border-left: 3px solid rgba(0, 0, 0, 0.2);
}

.message.own .reply-preview {
  background: rgba(255, 255, 255, 0.2);
  border-left-color: rgba(255, 255, 255, 0.4);
}

/* Media Messages */
.message-photo {
  max-width: 200px;
  max-height: 200px;
  border-radius: 12px;
  cursor: pointer;
  transition: transform 0.2s;
}

.message-photo:hover {
  transform: scale(1.02);
}

.document-message {
  display: flex;
  align-items: center;
  gap: 8px;
  background: rgba(0, 0, 0, 0.05);
  padding: 8px;
  border-radius: 8px;
  margin: 4px 0;
}

.message.own .document-message {
  background: rgba(255, 255, 255, 0.2);
}

.file-icon {
  color: #7B42F6;
  font-size: 16px;
}

.file-name {
  flex: 1;
  font-size: 13px;
  font-weight: 500;
}

.download-btn {
  background: #7B42F6;
  color: white;
  border: none;
  padding: 4px 8px;
  border-radius: 6px;
  font-size: 11px;
  cursor: pointer;
  transition: background-color 0.2s;
}

.download-btn:hover {
  background: #6B35E8;
}

/* Message Actions */
.message-actions {
  display: flex;
  gap: 4px;
  margin-top: 4px;
  opacity: 0;
  transition: opacity 0.2s;
}

.message:hover .message-actions {
  opacity: 1;
}

.reply-btn, .react-btn, .menu-btn {
  background: rgba(0, 0, 0, 0.05);
  border: none;
  border-radius: 50%;
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 12px;
  color: #65676b;
  transition: all 0.2s;
}

.reply-btn:hover, .react-btn:hover, .menu-btn:hover {
  background: rgba(0, 0, 0, 0.1);
  transform: scale(1.1);
}

/* Message Menu */
.message-menu {
  position: absolute;
  top: 100%;
  right: 0;
  background: white;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  z-index: 1000;
  min-width: 120px;
  overflow: hidden;
  animation: fadeIn 0.2s ease-out;
}

.menu-item {
  display: flex;
  align-items: center;
  gap: 8px;
  width: 100%;
  padding: 8px 12px;
  border: none;
  background: none;
  text-align: left;
  cursor: pointer;
  font-size: 14px;
  color: #1c1e21;
  transition: background-color 0.2s;
}

.menu-item:hover {
  background: #f2f3f5;
}

.menu-item.delete {
  color: #e41e3f;
}

.menu-item.delete:hover {
  background: #ffebee;
}

/* Reactions */
.message-reactions {
  display: flex;
  gap: 4px;
  margin-top: 4px;
  flex-wrap: wrap;
}

.reaction {
  display: flex;
  align-items: center;
  gap: 2px;
  background: rgba(255, 255, 255, 0.9);
  border-radius: 12px;
  padding: 2px 6px;
  font-size: 11px;
  cursor: pointer;
  transition: all 0.2s;
  border: 1px solid transparent;
}

.reaction:hover {
  transform: scale(1.05);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.reaction.own-reaction {
  background: #7B42F6;
  color: white;
  border-color: #7B42F6;
}

.reaction-emoji {
  font-size: 12px;
}

.reaction-count {
  font-weight: 500;
  min-width: 8px;
}

/* Reaction Picker */
.reaction-picker {
  position: fixed;
  background: white;
  border-radius: 25px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
  padding: 8px;
  display: flex;
  gap: 4px;
  z-index: 1001;
  animation: scaleIn 0.2s ease-out;
  bottom: 100%;
  margin-bottom: 8px;
}

.reaction-picker.below {
  top: 100%;
  bottom: auto;
  margin-top: 8px;
  margin-bottom: 0;
}

.reaction-picker.left-edge {
  left: 20px !important;
}

.reaction-picker.right-edge {
  right: 20px !important;
  left: auto !important;
}

.reaction-option {
  width: 36px;
  height: 36px;
  border: none;
  background: none;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  cursor: pointer;
  transition: all 0.2s;
}

.reaction-option:hover {
  background: rgba(0, 0, 0, 0.05);
  transform: scale(1.2);
}

.reaction-option.active {
  background: #7B42F6;
  transform: scale(1.1);
}

/* Reply/Edit Preview Bars - Fixed positioning */
.reply-preview-bar, .edit-preview-bar {
  background: #f0f2f5;
  border-left: 4px solid #7B42F6;
  padding: 8px 12px;
  margin: 8px 16px 0;
  border-radius: 0 8px 8px 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 13px;
  flex-shrink: 0; /* ✅ Prevent shrinking */
}

.reply-content, .edit-content {
  flex: 1;
}

.cancel-reply, .cancel-edit {
  background: none;
  border: none;
  color: #65676b;
  cursor: pointer;
  padding: 4px;
  border-radius: 50%;
  transition: background-color 0.2s;
}

.cancel-reply:hover, .cancel-edit:hover {
  background: rgba(0, 0, 0, 0.05);
}

/* Message Input - Fixed at bottom */
.message-input {
  display: flex;
  align-items: flex-end;
  padding: 8px 16px;
  background: #ffffff;
  border-top: 1px solid #e4e6ea;
  gap: 8px;
  flex-shrink: 0; /* ✅ Prevent input from shrinking */
  min-height: 60px; /* ✅ Ensure minimum height */
}

.input-actions {
  position: relative;
}

.action-btn {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  border: none;
  background: #7B42F6;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s;
}

.action-btn:hover {
  background: #6B35E8;
  transform: scale(1.05);
}

.media-options {
  position: absolute;
  bottom: 100%;
  left: 0;
  background: white;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  margin-bottom: 8px;
  overflow: hidden;
  min-width: 140px;
  animation: fadeIn 0.2s ease-out;
}

.media-options button {
  display: flex;
  align-items: center;
  gap: 8px;
  width: 100%;
  padding: 10px 12px;
  border: none;
  background: none;
  text-align: left;
  cursor: pointer;
  font-size: 14px;
  color: #1c1e21;
  transition: background-color 0.2s;
}

.media-options button:hover {
  background: #f2f3f5;
}

.input-field {
  flex: 1;
  position: relative;
}

.input-field input {
  width: 100%;
  border: none;
  outline: none;
  background: #f0f2f5;
  border-radius: 20px;
  padding: 8px 16px;
  font-size: 14px;
  resize: none;
  min-height: 36px;
  font-family: inherit;
}

.input-field input:focus {
  background: #e4e6ea;
}

.send-actions {
  display: flex;
  gap: 8px;
  align-items: center;
}

.send-media-btn {
  background: linear-gradient(135deg, #7B42F6 0%, #C86DD7 100%);
  color: white;
  border: none;
  padding: 8px 12px;
  border-radius: 18px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s;
}

.send-media-btn:hover {
  background: linear-gradient(135deg, #6B35E8 0%, #B85CC9 100%);
  transform: scale(1.02);
}

.send-btn {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  border: none;
  background: linear-gradient(135deg, #7B42F6 0%, #C86DD7 100%);
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s;
}

.send-btn:hover:not(:disabled) {
  background: linear-gradient(135deg, #6B35E8 0%, #B85CC9 100%);
  transform: scale(1.05);
}

.send-btn:disabled {
  background: #bcc0c4;
  cursor: not-allowed;
}

/* Typing Indicator */
.typing-indicator {
  display: flex;
  align-items: center;
  gap: 8px;
  margin: 8px 0;
  align-self: flex-start;
}

.typing-dots {
  display: flex;
  gap: 2px;
  background: #f0f2f5;
  padding: 8px 12px;
  border-radius: 18px;
}

.typing-dots span {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: #65676b;
  animation: typing 1.4s infinite ease-in-out;
}

.typing-dots span:nth-child(1) {
  animation-delay: -0.32s;
}

.typing-dots span:nth-child(2) {
  animation-delay: -0.16s;
}

.typing-text {
  font-size: 12px;
  color: #65676b;
  font-style: italic;
}

/* No Messages/Chat Selected - Fixed centering */
.no-messages, .no-chat-selected {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  flex: 1;
  color: #65676b;
  text-align: center;
  padding: 40px 20px;
}

.no-chat-icon {
  font-size: 48px;
  color: #bcc0c4;
  margin-bottom: 16px;
}

.no-messages h3, .no-chat-selected h3 {
  margin: 8px 0;
  color: #1c1e21;
  font-weight: 600;
}

.no-messages p, .no-chat-selected p {
  margin: 0;
  font-size: 14px;
}

/* Animations */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes scaleIn {
  from {
    opacity: 0;
    transform: scale(0.8);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

@keyframes typing {
  0%, 60%, 100% {
    transform: translateY(0);
  }
  30% {
    transform: translateY(-10px);
  }
}

/* Responsive Design */
@media (max-width: 768px) {
  .chat-container {
    margin: 0;
    height: calc(100vh - 80px); /* ✅ Account for bottom navigation */
  }
  
  .chat-messages {
    margin: 4px;
    border-radius: 0;
  }
  
  .message {
    max-width: 85%;
  }
  
  .messages-container {
    padding: 12px;
  }
  
  .message-input {
    padding: 12px;
  }
  
  .reaction-picker {
    position: fixed;
    left: 50% !important;
    transform: translateX(-50%);
    width: 280px;
  }
  
  .reaction-picker.left-edge,
  .reaction-picker.right-edge {
    left: 50% !important;
    right: auto !important;
  }
}

@media (max-width: 480px) {
  .chat-user-info h3 {
    font-size: 14px;
  }
  
  .user-status {
    font-size: 11px;
  }
  
  .message-content {
    border-radius: 12px;
  }
  
  .reaction-picker {
    width: 240px;
    padding: 6px;
  }
  
  .reaction-option {
    width: 32px;
    height: 32px;
    font-size: 16px;
  }
}