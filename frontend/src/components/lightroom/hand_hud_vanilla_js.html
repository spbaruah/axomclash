<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hand Tracking HUD (Vanilla JS)</title>
  <style>
    *{box-sizing:border-box}
    body{margin:0;background:#0f1115;color:#e5e7eb;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    .wrap{max-width:1100px;margin:20px auto;padding:0 12px}
    .topbar{display:flex;align-items:center;gap:12px;margin-bottom:12px}
    button{background:#2563eb;color:#fff;border:0;padding:10px 14px;border-radius:12px;cursor:pointer;font-weight:600}
    button:disabled{opacity:.5;cursor:not-allowed}
    select{background:#111827;color:#e5e7eb;border:1px solid #374151;border-radius:10px;padding:8px 10px}
    .capsule{background:#111827;border:1px solid #374151;color:#9ca3af;border-radius:999px;padding:8px 12px}
    .stage{position:relative;width:100%;aspect-ratio:16/9;background:#0b0d12;border-radius:16px;overflow:hidden;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    #video,#overlay{position:absolute;inset:0;width:100%;height:100%}
    #video{display:none}
    .hud{position:absolute;left:12px;bottom:12px;display:flex;gap:10px;align-items:center;z-index:5}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <button id="startBtn">Enable Camera</button>
      <span class="capsule" id="status">status: ready</span>
      <span class="capsule" id="gesture">gesture: —</span>
      <label class="capsule" style="display:flex;align-items:center;gap:8px">Speed
        <select id="speed">
          <option value="0.6">0.6x</option>
          <option value="0.8">0.8x</option>
          <option value="1" selected>1x</option>
          <option value="1.5">1.5x</option>
          <option value="2">2x</option>
          <option value="3">3x</option>
        </select>
      </label>
    </div>

    <div class="stage">
      <video id="video" playsinline></video>
      <canvas id="overlay"></canvas>
      <div class="hud">
        <span class="capsule" id="fps">fps: —</span>
      </div>
    </div>
  </div>

  <!-- MediaPipe (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

  <script>
  const videoEl   = document.getElementById('video');
  const canvasEl  = document.getElementById('overlay');
  const ctx       = canvasEl.getContext('2d');
  const startBtn  = document.getElementById('startBtn');
  const statusEl  = document.getElementById('status');
  const gestureEl = document.getElementById('gesture');
  const fpsEl     = document.getElementById('fps');
  const speedSel  = document.getElementById('speed');

  let camera=null,hands=null,lastLm=null; // landmarks
  let particles=[]; // trail particles
  let tPrev=performance.now(), fps=0;
  let canvasW=960, canvasH=540;

  function fitCanvas(){
    const r=canvasEl.getBoundingClientRect();
    canvasW=r.width; canvasH=r.height;
    canvasEl.width=canvasW; canvasEl.height=canvasH;
  }
  addEventListener('resize', fitCanvas); fitCanvas();
  const setStatus=t=>statusEl.textContent=`status: ${t}`;
  const setGesture=t=>gestureEl.textContent=`gesture: ${t}`;

  /* ===== Gesture helpers ===== */
  function fingerStates(lm){
    const idx={thumb_tip:4, thumb_ip:3, index_tip:8, index_pip:6, middle_tip:12, middle_pip:10, ring_tip:16, ring_pip:14, pinky_tip:20, pinky_pip:18};
    const tipAbove=(tip,pip)=>lm[tip].y < lm[pip].y; // y: top is 0
    const thumbExtended=Math.abs(lm[idx.thumb_tip].x - lm[idx.thumb_ip].x) > 0.05; // crude
    return {thumb:thumbExtended, index:tipAbove(idx.index_tip,idx.index_pip), middle:tipAbove(idx.middle_tip,idx.middle_pip), ring:tipAbove(idx.ring_tip,idx.ring_pip), pinky:tipAbove(idx.pinky_tip,idx.pinky_pip)};
  }
  function classifyGesture(lm){
    if(!lm) return '—';
    const s=fingerStates(lm);
    const up=[s.thumb,s.index,s.middle,s.ring,s.pinky].filter(Boolean).length;
    const d=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
    const pinch=d(lm[4],lm[8])<0.045;
    if(pinch) return 'pinch';
    if(s.index && !s.middle && !s.ring && !s.pinky) return 'point';
    if(up>=4) return 'open-palm';
    return 'unknown';
  }

  /* ===== Overlay drawing ===== */
  function drawCamera(){ ctx.drawImage(videoEl,0,0,canvasW,canvasH); }

  function drawLandmarks(lm){
    const Sx=canvasW,Sy=canvasH; const C=window.HAND_CONNECTIONS||[];
    ctx.lineWidth=2; ctx.strokeStyle='rgba(0,255,255,.5)';
    C.forEach(([a,b])=>{ctx.beginPath(); ctx.moveTo(lm[a].x*Sx,lm[a].y*Sy); ctx.lineTo(lm[b].x*Sx,lm[b].y*Sy); ctx.stroke();});
    lm.forEach(p=>{ctx.beginPath(); ctx.arc(p.x*Sx,p.y*Sy,4,0,Math.PI*2); ctx.fillStyle='rgba(0,255,255,.9)'; ctx.fill();});
  }

  function addTrail(lm){
    const Sx=canvasW,Sy=canvasH; const tip=lm[8]; const x=tip.x*Sx, y=tip.y*Sy;
    const speed=parseFloat(speedSel.value);
    for(let i=0;i<6*speed;i++){
      particles.push({x,y,vx:(Math.random()-.5)*2*speed,vy:(Math.random()-.5)*2*speed,life:1,r:2+Math.random()*2});
    }
  }
  function stepParticles(){
    for(let i=particles.length-1;i>=0;i--){
      const p=particles[i]; p.x+=p.vx; p.y+=p.vy; p.vy+=0.03; p.life-=0.02; if(p.life<=0){particles.splice(i,1); continue;}
      ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fillStyle=`rgba(0,200,255,${p.life})`; ctx.fill();
    }
  }

  // Decorative HUD elements (grid + cube on right)
  function drawGridAndCube(){
    const x0=canvasW*0.72, y0=canvasH*0.65, w=canvasW*0.24, h=canvasH*0.28; // panel area
    ctx.save();
    ctx.strokeStyle='rgba(255,100,100,.5)'; ctx.lineWidth=1.5;
    // grid
    const cols=8, rows=6; for(let i=0;i<=cols;i++){ const x=x0+(i/cols)*w; ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y0+h); ctx.stroke(); }
    for(let j=0;j<=rows;j++){ const y=y0+(j/rows)*h; ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x0+w,y); ctx.stroke(); }

    // wire cube
    const cx=x0+w*0.35, cy=y0+h*0.35, size=Math.min(w,h)*0.32; const d=size*0.5; // depth
    const pts=[[-d,-d,0],[d,-d,0],[d,d,0],[-d,d,0],[-d*0.7,-d*0.7,d],[d*0.7,-d*0.7,d],[d*0.7,d*0.7,d],[-d*0.7,d*0.7,d]];
    const proj=(X,Y,Z)=>[cx+X*1.0 + Z*0.35, cy+Y*1.0 + Z*0.2];
    const P=pts.map(([X,Y,Z])=>proj(X,Y,Z));
    const edges=[[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
    ctx.strokeStyle='rgba(255,100,150,.65)';
    edges.forEach(([a,b])=>{ctx.beginPath(); ctx.moveTo(P[a][0],P[a][1]); ctx.lineTo(P[b][0],P[b][1]); ctx.stroke();});

    // little bars (like sensor readouts)
    const barsX=x0+w*0.05, barsY=y0+h*0.08; const barW=w*0.18, barH=6, gap=8;
    for(let i=0;i<8;i++){
      const val=Math.abs(Math.sin((performance.now()/600)+(i*0.7)));
      ctx.fillStyle='rgba(150,200,255,.6)';
      ctx.fillRect(barsX, barsY+i*(barH+gap), barW*val, barH);
      ctx.strokeStyle='rgba(150,200,255,.25)'; ctx.strokeRect(barsX, barsY+i*(barH+gap), barW, barH);
    }

    // tiny text
    ctx.fillStyle='rgba(210,220,255,.7)'; ctx.font='12px ui-monospace, SFMono-Regular, Menlo, monospace';
    ctx.fillText('friction: 0.55', x0+w*0.55, y0+h*0.15);
    ctx.fillText('signal: 92%', x0+w*0.55, y0+h*0.15+16);
    ctx.fillText('index-trace', x0+w*0.55, y0+h*0.15+32);

    ctx.restore();
  }

  /* ===== MediaPipe callbacks ===== */
  function onResults(res){
    const now=performance.now(); const dt=now-tPrev; tPrev=now; fps = Math.round(1000/dt);
    fpsEl.textContent = `fps: ${fps}`;

    lastLm = (res.multiHandLandmarks && res.multiHandLandmarks[0]) || null;

    drawCamera();
    drawGridAndCube();

    if(lastLm){
      drawLandmarks(lastLm);
      addTrail(lastLm);
      setGesture(classifyGesture(lastLm));
    } else {
      setGesture('—');
    }
    stepParticles();
  }

  async function init(){
    setStatus('loading…');
    hands = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
    hands.setOptions({ maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.6, minTrackingConfidence:0.6 });
    hands.onResults(onResults);

    startBtn.addEventListener('click', async ()=>{
      startBtn.disabled=true; setStatus('starting camera…');
      const cam = new Camera(videoEl, { onFrame: async()=>{ await hands.send({ image: videoEl }); }, width:960, height:540 });
      camera = cam;
      try { await camera.start(); setStatus('camera running'); }
      catch(e){ console.error(e); setStatus('camera blocked (allow permissions)'); startBtn.disabled=false; }
    });
    setStatus('ready');
  }
  init();
  </script>
</body>
</html>
